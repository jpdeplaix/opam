(**************************************************************************)
(*                                                                        *)
(*    Copyright 2017 OCamlPro                                             *)
(*                                                                        *)
(*  All rights reserved. This file is distributed under the terms of the  *)
(*  GNU Lesser General Public License version 2.1, with the special       *)
(*  exception on linking described in the file LICENSE.                   *)
(*                                                                        *)
(**************************************************************************)

open OpamCudfSolverSig

let log f = OpamConsole.log "ZI" f

let name = "builtin-zi"

let ext = ref None

let is_present () = true

let command_name = None

let default_criteria = {
  crit_default = "-removed,\
                  -count[version-lag,request],\
                  -count[version-lag,changed],\
                  -changed";
  crit_upgrade = "-removed,\
                  -count[version-lag,solution],\
                  -new";
  crit_fixup = "-changed,-count[version-lag,solution]";
  crit_best_effort_prefix = Some "+count[opam-query,solution],";
}

let pkgname_eq pkg (name, _) =
  String.equal pkg name

let not_relop = function
  | `Eq -> `Neq
  | `Neq -> `Eq
  | `Geq -> `Lt
  | `Gt -> `Leq
  | `Leq -> `Gt
  | `Lt -> `Geq

let call ~criteria:_ ?timeout:_ (preamble, universe, request) =
  let spec =
    request.Cudf.install @
    request.Cudf.upgrade @
    Cudf.fold_packages (fun acc pkg ->
        if pkg.Cudf.installed &&
           not (List.exists (pkgname_eq pkg.Cudf.package) request.Cudf.install) &&
           not (List.exists (pkgname_eq pkg.Cudf.package) request.Cudf.upgrade) &&
           not (List.exists (pkgname_eq pkg.Cudf.package) request.Cudf.remove) then
          (pkg.Cudf.package, Some (`Eq, pkg.Cudf.version)) :: acc
        else
          acc
      ) [] universe
  in
  let constraints =
    spec |>
    List.filter_map (function
      | _, None -> None
      | x, Some y -> Some (x, y)
    )
  in
  let constraints =
    constraints @
    List.filter_map (function
      | _, None -> None
      | x, Some (relop, y) -> Some (x, (not_relop relop, y))
    ) request.Cudf.remove
  in
  let pkgs = List.map fst spec in
  let context = Opam_zi.create ~constraints universe in
  (* Try to find a solution: *)
  let t0 = Unix.gettimeofday () in
  let r = Opam_zi.solve context pkgs in
  match r with
  | Ok sels ->
    let universe =
      Opam_zi.packages_of_result sels |>
      List.fold_left (fun pkgs (pkg, v) ->
        let pkg = Cudf.lookup_package universe (pkg, v) in
        {pkg with was_installed = pkg.installed; installed = true} :: pkgs
      ) [] |>
      Cudf.load_universe
    in
    let t1 = Unix.gettimeofday () in
    OpamConsole.note "Solution found. Solve took %.2f s" (t1 -. t0);
    (Some preamble, universe)
  | Error problem ->
    let t1 = Unix.gettimeofday () in
    OpamConsole.note "No solution. Solve took %.2f s" (t1 -. t0);
(* Diagnostics disabled. Feel free to enable again for debug *)
(*    print_endline (Opam_zi.diagnostics problem);
    let t1 = Unix.gettimeofday () in
    OpamConsole.note "Eliminated all possibilities in %.2f s" (t1 -. t0); *)
    raise Common.CudfSolver.Unsat
