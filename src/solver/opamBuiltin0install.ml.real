(**************************************************************************)
(*                                                                        *)
(*    Copyright 2017 OCamlPro                                             *)
(*                                                                        *)
(*  All rights reserved. This file is distributed under the terms of the  *)
(*  GNU Lesser General Public License version 2.1, with the special       *)
(*  exception on linking described in the file LICENSE.                   *)
(*                                                                        *)
(**************************************************************************)

open OpamCudfSolverSig

let log f = OpamConsole.log "0install" f

let name = "builtin-0install"

let ext = ref None

let is_present () = true

let command_name = None

let default_criteria = {
  crit_default = "";
  crit_upgrade = "";
  crit_fixup = "";
  crit_best_effort_prefix = None;
}

let should_be_left_installed pkg request =
  let pkgname_eq pkg (name, _) = String.equal pkg name in
  pkg.Cudf.installed &&
  not (List.exists (pkgname_eq pkg.Cudf.package) request.Cudf.install) &&
  not (List.exists (pkgname_eq pkg.Cudf.package) request.Cudf.upgrade) &&
  not (List.exists (pkgname_eq pkg.Cudf.package) request.Cudf.remove)

let not_relop = function
  | `Eq -> `Neq
  | `Neq -> `Eq
  | `Geq -> `Lt
  | `Gt -> `Leq
  | `Leq -> `Gt
  | `Lt -> `Geq

let essential (pkg, c) = ((pkg, `Essential), c)
let recommended (pkg, c) = ((pkg, `Recommended), c)

let call ~criteria:_ ?timeout:_ (preamble, universe, request) =
  let spec =
    List.map essential request.Cudf.install @
    List.map essential request.Cudf.upgrade @
    Cudf.fold_packages (fun acc pkg ->
        match pkg.Cudf.keep with
        | `Keep_version -> essential (pkg.Cudf.package, Some (`Eq, pkg.Cudf.version)) :: acc
        | `Keep_package -> essential (pkg.Cudf.package, None) :: acc
        | `Keep_feature -> assert false (* TODO: Is this used? *)
        | `Keep_none when should_be_left_installed pkg request -> recommended (pkg.Cudf.package, None) :: acc
        | `Keep_none -> acc
      ) [] universe
  in
  let constraints =
    List.filter_map (function
      | _, None -> None
      | (pkg, _), Some c -> Some (pkg, c)
    ) spec
  in
  let pkgs = List.map fst spec in
  let pkgs, constraints =
    List.fold_left (fun (pkgs, constraints) -> function
      | pkg, None -> ((pkg, `Restricts) :: pkgs, constraints)
      | pkg, Some (relop, y) -> (pkgs, (pkg, (not_relop relop, y)) :: constraints)
    ) (pkgs, constraints) request.Cudf.remove
  in
  let context = Opam_0install_cudf.create ~constraints universe in
  let t0 = Unix.gettimeofday () in
  let r = Opam_0install_cudf.solve context pkgs in
  match r with
  | Ok sels ->
    let universe =
      Opam_0install_cudf.packages_of_result sels |>
      List.fold_left (fun pkgs (pkg, v) ->
        let pkg = Cudf.lookup_package universe (pkg, v) in
        {pkg with was_installed = pkg.installed; installed = true} :: pkgs
      ) [] |>
      Cudf.load_universe
    in
    let t1 = Unix.gettimeofday () in
    log "Solution found. Solve took %.2f s" (t1 -. t0);
    (Some preamble, universe)
  | Error _problem ->
    let t1 = Unix.gettimeofday () in
    log "No solution. Solve took %.2f s" (t1 -. t0);
    (* Diagnostics disabled. Feel free to enable again for debug *)
    (* print_endline (Opam_0install_cudf.diagnostics problem); *)
    raise Common.CudfSolver.Unsat
